<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Chapter 4: Entering the Third Dimension | OpenGLBook.com</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">
        <script type="text/javascript" src="//code.jquery.com/jquery-2.1.0.min.js"></script>
        <script type="text/javascript" src="/scripts/jsglhl.js"></script>
        <script type="text/javascript">
        $(document).ready(function() {
          LinkOpenGLManPages();
        });
        </script>
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>

        <div class="site">
          
          <div class="header">
            <h1 class="title"><a href="/">OpenGLBook.com</a></h1>
          </div>

          <div id="navigation">
            <div class="menu">
              <ul>
                <li class="page_item">
                  <a href="/">Home</a>
                </li>
                <li class="page_item">
                  <a href="/the-book.html">The Book</a>
                  <ul class="children">
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                      <li><a href="/chapter-0-preface-what-is-opengl.html">Preface: What is OpenGL?</a></li>
                      
                    
                      
                      <li><a href="/chapter-1-getting-started.html">Chapter 1: Getting Started</a></li>
                      
                    
                      
                      <li><a href="/chapter-2-vertices-and-shapes.html">Chapter 2: Vertices and Shapes</a></li>
                      
                    
                      
                      <li><a href="/chapter-3-index-buffer-objects-and-primitive-types.html">Chapter 3: Index Buffer Objects and Primitive Types</a></li>
                      
                    
                      
                      <li><a href="/chapter-4-entering-the-third-dimension.html">Chapter 4: Entering the Third Dimension</a></li>
                      
                    
                      
                      <li><a href="/credits.html">Credits</a></li>
                      
                    
                  </ul>
                </li>
                <li class="page_item">
                  <a href="/blog/">Blog</a>
                </li>
                <li class="page_item">
                  <a href="#">Report Issues</a>
                  <ul class="children">
                    <li>
                      <a href="https://github.com/openglbook/openglbook.com/issues">
                        Text Issues (typos, etc.)
                      </a>
                    </li>
                    <li>
                      <a href="https://github.com/openglbook/openglbook-samples/issues">Code Issues (bugs, etc.)</a>
                    </li>
                  </ul>
                </li>
              </ul>
            </div>
          </div>

          <h1>Chapter 4: Entering the Third Dimension</h1>

<p><img
  src="/images/Chapter4.1-Output-300x234.png"
  alt="Chapter 4 Output"
  title="Chapter 4 Output"
  class="right"
/></p>

<p>If you&#39;re learning OpenGL, it&#39;s very likely you&#39;re doing so to learn how to
render three-dimensional data. In this chapter, we&#39;ll be placing our very first
step in the world of three-dimensional computer graphics. We&#39;ll learn:</p>

<ul>
<li>The mathematics used to describe transformations in a three-dimensional world</li>
<li>What coordinate systems are good for and how to use them</li>
<li>What polygon culling is and why it&#39;s used</li>
<li>How to render a rotating colored cube to the screen</li>
<li>Some new OpenGL function calls</li>
</ul>

<p>As mentioned in the preface, you&#39;ll need some mathematical knowledge in order to
understand some of the concepts presented, preferably knowledge of linear
algebra. The mathematics in this chapter is as lightweight as possible without
sacrificing the integrity of the presented concept.</p>

<p><strong><a href="/chapter-0-preface-what-is-opengl.html">Check the requirements before continuing</a></strong></p>

<div class="FYI">
  <strong>OpenGL 3.x / DirectX 10 Level Hardware</strong>
  <p>
    This chapter is 100% compatible with OpenGL 3.x level hardware by changing
    only a few lines of code.
  </p>
</div>

<h1>Utilities</h1>

<p>We use many of the functions from this chapter in the rest of the book, so let&#39;s
create a few files that we can carry over from chapter to chapter. Please note
that all of the functionality in this book is for demonstration purposes, and
not optimized for performance. The functions provided here are verbose by design
so that the flow of the code is easy to understand.</p>

<p>If you are looking for a professional-grade 3D mathematics library, you can find
several excellent open source C++ libraries on the Internet or roll your own
using high performance code. However, for this book, we&#39;re going to create a
file called <code>Utils.h</code>, and add the following lines:</p>

<!--- 4.1 -->

<script src="https://gist.github.com/EddyLuten/11242920.js"> </script>

<p>Now create a second file named <code>Utils.c</code> and insert the following lines:</p>

<!--- 4.2 -->

<script src="https://gist.github.com/EddyLuten/11242940.js"> </script>

<h1>Step-By-Step: Mathematics</h1>

<p>If you&#39;re unfamiliar with the basics of linear algebra, much of the code in the
listing from the previous section will seem like gibberish, and the rest of this
chapter may be hard to follow. A few resources for learning linear algebra are
listed in the chapter&#39;s conclusion. In the next sections, we&#39;ll explore what
matrices are at a glance, how to use them in three-dimensional computer
graphics, and how they are used in the code you&#39;ve just copied.</p>

<p>You may ask yourself &quot;how important is it to know all these calculations by
heart?&quot; For most of computer graphics, it is okay just to know the applications
of the calculations since you&#39;d store them in reusable functions. However, for 
complex computation, you would have to come up with calculations of your own
using matrices, transformations, and other linear algebra.</p>

<h2>The Matrix</h2>

<p>A matrix is a mathematical construct that describes a grid (or array) of numbers
composed of <em>m</em> row vectors and <em>n</em> column vectors. We use
matrices to describe transformations from one coordinate space to another, such
as rotation, scaling, translation, etc. In our programs, we use one type of
matrix, namely the 4x4 square matrix (a matrix is square when <em>n</em> =
<em>m</em>). Let&#39;s look at our 4x4 matrix <strong>M</strong>:</p>

<p><span>
\(
\mathbf{M} = \begin{bmatrix}
1 &amp; 2 &amp; 3 &amp; 4 \\
5 &amp; 6 &amp; 7 &amp; 8 \\
9 &amp; 10 &amp; 11 &amp; 12 \\
13 &amp; 14 &amp; 15 &amp; 16
\end{bmatrix}\cdot
\)
</span></p>

<p>The notation used to access the single value stored in row 2, column 4 is:</p>

<p><span>\(M_{24} = 8\)</span></p>

<p>In a three-dimensional coordinate system such as ours, a 4x4 matrix contains the
transformations for each axis in each <strong>column vector</strong>, which are the four
horizontal columns that make up the matrix:</p>

<p><span>
\(
\mathbf{M} = \begin{bmatrix}
 Xx &amp; Yx &amp; Zx &amp; Tx \\
 Xy &amp; Yy &amp; Zy &amp; Ty \\
 Xz &amp; Yz &amp; Zz &amp; Tz \\
 0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}\cdot
\)
</span></p>

<p>The first three column vectors contain the x-, y-, and z-axes&#39; transformations
respectively, while the last column vector contains the translation, which we&#39;ll
explore further below.</p>

<p>In our programs, we represent matrices with the structure <code>Matrix</code>, which
contains an array of 16 floating-point elements, the total amount of elements in
a 4x4 matrix. All of the matrix operations in <code>Utils.h</code> operate on this
structure.</p>

<h2>Matrix Multiplication</h2>

<p>Before we continue with the explanation of how these transformations work, make
sure that you fully understand matrix multiplication since we&#39;ll use it many
times in this chapter by using the <code>MultiplyMatrices</code> function from the files
that we&#39;ve just created. Matrix multiplication is very important since it allows
us to transform points from one coordinate system to another.</p>

<p>To understand how matrix multiplication works, let&#39;s take the following 2x2
matrices for simplicity&#39;s sake, which we&#39;ll name <strong>A</strong> and <strong>B</strong>:</p>

<div>
\(
\begin{aligned}
\mathbf{A} = \begin{bmatrix}
 1 &amp; 2 \\\\
 3 &amp; 4
\end{bmatrix}\cdot
\\\\
\mathbf{B} = \begin{bmatrix}
 5 &amp; 6 \\\\
 7 &amp; 8
\end{bmatrix}\cdot
\end{aligned}
\)
</div>

<p>In order to get the product of <strong>A</strong> and <strong>B</strong>, which we&#39;ll name matrix <strong>C</strong>,
we&#39;ll have to multiply each row vector in matrix <strong>A</strong> with each column vector
in matrix <strong>B</strong>.</p>

<p>This means that if we wish to find the value to go into <span>\(C_{11}\)</span>,
we&#39;ll have to perform the following calculation:</p>

<div>
\(C_{11} = A_{11}B_{11} + A_{12}B_{21} = 1\cdot5 + 2\cdot7 = 5+14 = 19\)
</div>

<p>This is the same as the <strong>dot product</strong> of the first row vector of matrix <strong>A</strong>
and the first column vector of matrix <strong>B</strong>. We repeat this process for the
entire matrix, resulting in the following calculation for the 2x2 matrices:</p>

<div>
\(
\mathbf{C} =
\begin{bmatrix}
(A_{11}B_{11}+A_{12}B_{21}) &amp; (A_{11}B_{12}+A_{12}B_{22}) \\\\
(A_{21}B_{11}+A_{22}B_{21}) &amp; (A_{21}B_{12}+A_{22}B_{22})
\end{bmatrix}
=
\begin{bmatrix}
19 &amp; 22 \\\\
43 &amp; 50
\end{bmatrix}
\cdot
\)
</div>

<p>If we had used a 4x4 matrix multiplication instead of the above 2x2, the
calculation would be much more extensive and best handled by a computer unless
you enjoy multiplying matrices by hand. Note that matrix multiplication is <em>not</em>
commutative, meaning that <strong>AB</strong> is not <strong>BA</strong> except when either <strong>A</strong> or <strong>B</strong>
is an identity matrix (described below).</p>

<p>Our <code>MultiplyMatrices</code> function multiplies matrices <code>m1</code>, the multiplier, and
<code>m2</code>, the multiplicand, and returns the product as a brand new matrix.</p>

<h2>Identity Matrix</h2>

<p>An important type of matrix is the identity matrix, which when multiplied by,
produces the multiplicand. It is important because it serves as the basis for
our transformations:</p>

<div>
\(
\mathbf{I} =
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\cdot
\)
</div>

<p>Identity matrices can only be formed from square matrices (<em>m</em> = <em>n</em>), and are
visually distinguishable by a line of number ones along its <strong>main diagonal</strong>
(which runs from top left to bottom right), whereas the rest of the matrix
contains zeroes.</p>

<p>Another way of looking at an identity matrix is by the fact that it&#39;s composed
of unit vectors. The column vector for x points in the x-direction, the column
vector for y in the y-direction, the column vector for z in the z-direction, and
the column vector used for translation set to zero for no translation.</p>

<p>Our own identity matrix is stored in the <code>IDENTITY_MATRIX</code> constant, defined in
the <code>Utils.h</code> file. If you browse through some of the functions in <code>Utils.c</code>,
you&#39;ll notice that we use an identity matrix for almost every transformation.</p>

<h2>Transformations</h2>

<p>This brings us to the topic of transformations, which are an important tool in
three-dimensional computer graphics. In fact, three-dimensional computer
graphics would not be possible were it not for transformations. Transformations
allow us to transform a point in space from one location to another using matrix
multiplication. There are two transformation types used, affine transformations
and projective transformations.</p>

<p><strong>Affine transformations</strong> allow us to translate, rotate, scale, or shear our
points in space relative to an origin using matrices. Most affine
transformations do not alter the physical properties of an object, meaning that
the distances from one point to another do no change.</p>

<p><strong>Projective transformations</strong> on the other hand, transform points in order to
&quot;project&quot; them onto a flat viewing plane, thus changing the properties of an
object significantly. One example of such a projective transformation is the
perspective projection matrix, which we will explore further on in this chapter.</p>

<h3>Transformation Pipeline</h3>

<p>Before we continue describing the various transformations in <code>Utils.h</code>, there&#39;s
the important subject of coordinate systems. As you know, a coordinate system is
a method used to describe the position of a point within a space, which in our
case is three-dimensional. In computer graphics, we use several coordinate
systems to transform our point to a displayable entity in a process called the
<strong>transformation pipeline</strong>, let&#39;s take a quick look at each of its stages.</p>

<h4>Object Space</h4>

<p>The transformation pipeline starts in <strong>object space</strong>, which hosts an object&#39;s
local coordinates, called <strong>object coordinates</strong>. These are the raw vertices
provided by the modeling software, or as to relate it to the previous chapter,
the points stored in the vertex buffer object.</p>

<h4>World Space</h4>

<p>To get the objects in a position relative to your world&#39;s origin, we transform
its vertices using a <strong>modeling transform</strong> to bring them into <strong>world space</strong>.
There could be several more steps for objects positioned relative to each other,
also called modeling transforms.</p>

<h4>Eye Space</h4>

<p>Now that the object&#39;s position is relative to the world&#39;s origin, the next step
is the <strong>view transform</strong>, which positions the world relative to the viewer&#39;s
position, bringing the object into <strong>eye space</strong>. The viewer&#39;s position is the
camera&#39;s position within the scene, but not the camera&#39;s function.</p>

<div class="FYI">
  <strong>FYI: The Model-View Matrix Concept</strong>
  <p>
    Often in code samples, you'll notice something called a "model-view"
    transformation as a single step. This is because when you multiply matrices,
    transforms combine into a single matrix. While this practice is not wrong,
    and can actually save a tiny fraction of bandwidth, we don't use
    "model-view" matrices in this book to maintain proper coordinate system
    terminologies and avoid confusion.
  </p>
</div>

<h4>Clip Space</h4>

<p>The next step is to determine which vertices are actually viewable by the camera
though a <strong>projection transformation</strong> after which the points are in <strong>clip
space</strong>. We discuss the concept of viewing volumes and clipping at a later point
in this chapter.</p>

<h4>Normalized Device Space</h4>

<p>The next step is to perform <strong>perspective division</strong> (or perspective
projection), which brings our vertices into <strong>normalized device space</strong>. For
OpenGL to be able to perform its rasterizing operations on the vertex data
provided, the data needs to be in a two-dimensional format, along with a depth
value for depth buffering.</p>

<h4>Window Space</h4>

<p>After the transformation to normalized device space, OpenGL takes over and feeds
the vertex data into a process called rasterization, which generates fragments
for the triangles, lines, and points that we described with our vertex
information. At this point, OpenGL also applies the depth information to
determine which fragments to discard due to overlap. After the composition of
all the final fragments, the graphics hardware outputs the final image to the
screen.</p>

<h3>Translation Matrix</h3>

<p>To move (or translate) a point from its origin, we must use what&#39;s called a
translation matrix. The translation matrix stores the magnitude of the
translation for each of the three dimensions in the last column vector of the
4x4 matrix:</p>

<div>
\(
\mathbf{T}=\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; Tx \\
0 &amp; 1 &amp; 0 &amp; Ty \\
0 &amp; 0 &amp; 1 &amp; Tz \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}\cdot
\)
</div>

<p>This matrix looks very similar to the identity matrix described earlier, with
the exception of its last column vector. Multiplying by this matrix preserves
rotation as well as scaling since the top left part of the matrix, where scaling
and rotation values are stored, contains a 3x3 identity matrix.</p>

<p>Let&#39;s see how translation works, by translating the following point, represented
as a column vector, three units along the y-axis:</p>

<div>
\(
\begin{bmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 3 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{bmatrix}
\begin{bmatrix}
1 \\
2 \\
3 \\
1
\end{bmatrix}
=
\begin{bmatrix}
1 \\
5 \\
3 \\
1
\end{bmatrix}
\cdot
\)
</div>

<p>This operation is simple enough, and you can easily visualize how the
y-component of the column vector increases its magnitude. This same principle
applies to matrices when we wish to move an entire coordinate system instead of
a single point:</p>

<div>
\(
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 3 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
1 &amp; 2 &amp; 3 &amp; 4\\
2 &amp; 3 &amp; 4 &amp; 1\\
3 &amp; 4 &amp; 1 &amp; 2\\
4 &amp; 1 &amp; 2 &amp; 3
\end{bmatrix}
=
\begin{bmatrix}
1 &amp; 2 &amp; 3 &amp; 4\\
14 &amp; 6 &amp; 10 &amp; 10\\
3 &amp; 4 &amp; 1 &amp; 2\\
4 &amp; 1 &amp; 2 &amp; 3
\end{bmatrix}
\cdot
\)
</div>

<p>Notice how only the y-components of each column vector changes, since it&#39;s the
only direction translated.</p>

<p>The function that we use to translate matrices is <code>TranslateMatrix</code>, which takes
in a pointer to the matrix to translate, and x-, y-, and z-components that make
up the translation stored in the translation column vector of the matrix.</p>

<h3>Scaling Matrix</h3>

<p>The matrix used for scaling transformations should look very familiar by now:</p>

<div>
\(
\mathbf{S}=\begin{bmatrix}
Sx &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; Sy &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; Sz &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}\cdot
\)
</div>

<p>This matrix looks remarkably similar to the identity matrix described earlier,
only in this matrix the values on the main diagonal are scaling factors. This
means that a scaling matrix with all of its scaling factors set to one is equal
to an identity matrix, and will not change its multiplicand.</p>

<p>These scaling values may be positive for scaling outward (expansion), or
negative for scaling inward (contraction). To scale in a single direction,
simply set the directions you do not wish to scale to one (as with an identity
matrix) and scale the remaining directions.</p>

<p>To scale an entire matrix by a factor of two in all directions, we would apply
the following transformation:</p>

<div>
\(
\begin{bmatrix}
2 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 2 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 2 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
1 &amp; 2 &amp; 3 &amp; 4\\
2 &amp; 3 &amp; 4 &amp; 1\\
3 &amp; 4 &amp; 1 &amp; 2\\
4 &amp; 1 &amp; 2 &amp; 3
\end{bmatrix}
=
\begin{bmatrix}
2 &amp; 4 &amp; 6 &amp; 8\\
4 &amp; 6 &amp; 8 &amp; 2\\
6 &amp; 8 &amp; 2 &amp; 4\\
4 &amp; 1 &amp; 2 &amp; 3
\end{bmatrix}\cdot
\)
</div>

<p>The function that we use to scale is <code>ScaleMatrix</code>, which takes in a pointer to
the matrix to scale, and x-, y-, and z-components that define the scaling vector.</p>

<h3>Rotation</h3>

<p>To rotate, we use three separate matrices, each of which defines a rotation
about the x-, y-, or z-axis, respectively. Let&#39;s look at the matrix required to
rotate a point about its x-axis:</p>

<div>
\(
R_{x}(\theta)=\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \cos\theta &amp; -\sin\theta &amp; 0 \\
0 &amp; \sin\theta &amp; \cos\theta &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}\cdot
\)
</div>

<p>If you look closely, you&#39;ll notice that this transformation does not affect the
x-components of the column vectors or the x-column vector itself. This is
because we rotate <strong>about</strong> an axis, visualized by rolling the axis of rotation
between your fingers, so only the y- and z-vectors change direction:</p>

<p><img
  src="/images/4262_03_01.png"
  alt="Rotation about X"
  title="Rotation about X"
  class="center"
/></p>

<p>The same principle applies to the rotation about the y-axis:</p>

<div>
\(
R_{y}(\theta)=\begin{bmatrix}
\cos\theta &amp; 0 &amp; \sin\theta &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
-\sin\theta &amp; 0 &amp; \cos\theta &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}\cdot
\)
</div>

<p><img
  src="/images/4262_03_02.png"
  alt="Rotation about Y"
  title="Rotation about Y"
  class="center"
/></p>

<p>As well as the z-axis:</p>

<div>
\(
R_{z}(\theta)=\begin{bmatrix}
\cos\theta &amp; -\sin\theta &amp; 0 &amp; 0 \\
\sin\theta &amp; \cos\theta &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}\cdot
\)
</div>

<p><img
  src="/images/4262_03_03.png"
  alt="Rotation about Z"
  title="Rotation about Z"
  class="center"
/></p>

<p>One thing to keep in mind when using rotation matrices is the order in which
the rotations are applied to the point. A rotation about the x-axis followed
by a rotation about the z-axis is not the same as a rotation about the z-axis
followed by a rotation about the x-axis. Take for example the following matrix
<strong>R</strong>:</p>

<div>
\(
\mathbf{R} = \begin{bmatrix}
5 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 6 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 7 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}\cdot
\)
</div>

<p>When we rotate <strong>R</strong> 45-degrees about the y-axis, followed by a 90-degree
rotation about the x-axis, the resulting matrix is:</p>

<div>
\(
\mathbf{R'} = \begin{bmatrix}
3.53 &amp; -3.53 &amp; 1.54 &amp; 0 \\
0 &amp; 0 &amp; -6 &amp; 0 \\
4.94 &amp; 4.94 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}\cdot
\)
</div>

<p>Whereas a 90-degree rotation about the x-axis followed by a 45-degree rotation
about the y-axis would result in this matrix:</p>

<div>
\(
\mathbf{R'} = \begin{bmatrix}
3.53 &amp; 0 &amp; -3.53 &amp; 0 \\
-4.24 &amp; 0 &amp; -4.24 &amp; 0 \\
0 &amp; 7 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}\cdot
\)
</div>

<p>We represent each of these rotational transformations with its own function in
<code>Utils.h</code>: <code>RotateAboutX</code>, <code>RotateAboutY</code>, and <code>RotateAboutZ</code>, which all take
in a pointer to the matrix to rotate as well as an angle of rotation in radians.</p>

<h3>Projection Matrices</h3>

<p>The last transformation we&#39;ll discuss is very different from the previously
mentioned ones. Its purpose is to <em>project</em> points onto a two-dimensional plane
instead of transforming points in a three-dimensional world. Because of this
behavior, we call this type of matrix a <strong>projection matrix</strong>. There are two
major types of projections used in three-dimensional computer graphics, namely
orthogonal projection and perspective projection.</p>

<p><strong>Orthogonal projection</strong> (also called parallel projection) doesn&#39;t apply
foreshortening to lines, meaning that lines don&#39;t converge towards a point as
in real life. With orthogonal projection, parallel lines will remain parallel,
and will never intersect. This type of transformation is very useful in
three-dimensional modeling programs where many objects at various distances
display in a single viewport but require the same vertex transformations
executed simultaneously.</p>

<p><strong>Perspective projection</strong> on the other hand, mimics the real-life visual effect
of foreshortening where objects at a distance appear smaller than objects
nearby. This means that parallel lines will eventually intersect at a vanishing
point, much like train tracks running off towards the horizon.</p>

<h3>Perspective Projection</h3>

<p>The function we use for perspective projection is <code>CreateProjectionMatrix</code>,
which takes in the following parameters:</p>

<ul>
<li><code>fovy</code>, which represents the vertical field-of-view angle in radians, this is
the angle between the top plane of the view frustum (see below) and the bottom
plane</li>
<li><code>aspect_ratio</code>, which is the ratio of width to the height of the viewport</li>
<li><code>near_plane</code>, which is the distance from the eye to the near plane</li>
<li><code>far_plane</code>, which is the distance from the eye to the far plane</li>
</ul>

<p>If you&#39;ve used OpenGL&#39;s fixed functionality, you&#39;ll probably recognize that
this function is very similar to <code>gluPerspective</code>, and in fact,
<code>CreateProjectionMatrix</code> mimics the behavior of this function exactly. We use
this single matrix to convert the vertices from eye space to clip space as well
as from clip space to normalized device space.</p>

<p>The parameters above describe a so-called <strong>viewing frustum</strong> (also called a
viewing volume), used to determine which points to project onto the viewing
plane:</p>

<p><img
  src="/images/4262_03_04-300x89.png"
  alt="Viewing Frustum"
  title="Viewing Frustum"
  class="center"
/></p>

<p>A frustum is a pyramid-like shape with its top cut off. The near and far planes
have the same aspect ratio as your viewport. Because of this preservation of
aspect ratio, your geometry will no longer look stretched when the window
resizes as in the previous chapters. Projective transformation applies only to
those points that fall within the viewing frustum, meaning that we clip the
points that lie outside of the frustum.</p>

<p>To obtain normalized device coordinates, we map the entire viewing frustum to
an axis-aligned cube measuring 2x2x2 units, located at the world&#39;s origin. This
cube exists in order to facilitate the projection of the vertices onto the
<strong>projection plane</strong> by OpenGL through parallel projection. After the vertices
are in normalized device space, OpenGL is ready to use these points for
rasterization.</p>

<div class="FYI">
  <strong>FYI: Geometrical Concepts</strong>
  <p>
    When we speak of the viewing frustum and the normalized device coordinates
    cube, it's important to note that we don't generate actual geometry for
    these shapes. The planes of the frustum and the sides of the cube simply
    represent minimum and maximum boundaries for the vertices.
  </p>
</div>

<p>In most cases, you don&#39;t have to know the specifics of the projection matrix
since the implementation rarely ever changes: simply define the code once and
copy it into all of your projects. Until the OpenGL 3 version branch, the
generation of the perspective projection matrix was part of OpenGL through the
<code>glFrustum</code> function or GLU&#39;s <code>gluPerspective</code>.</p>

<p>To apply perspective projection transformations, we use the following matrix:</p>

<div>
\(
\mathbf{P}=\begin{bmatrix}
xScale &amp; 0 &amp; 0 &amp; 0\\
0 &amp; yScale &amp; 0 &amp; 0\\
0 &amp; 0 &amp; -\frac{zFar+zNear}{zFar - zNear} &amp; -\frac{2 \cdot zNear \cdot zFar}{zFar - zNear} \\
0 &amp; 0 &amp; -1 &amp; 0
\end{bmatrix}\cdot
\)
</div>

<p>Where <span>\(yScale = \cot (\frac{fovy}{2})\)</span> and
<span>\(xScale = \frac{f}{aspect}\)</span>.</p>

<p>See the <code>CreateProjectionMatrix</code> function in the file <code>Utils.c</code> for
implementation details.</p>

<h1>Drawing a Cube</h1>

<p>Now that you have a basic knowledge of transformations, let&#39;s apply them and
draw a rotating cube to the screen. Once again, the program that we created in
chapter one serves as the basis for this exercise, so copy <code>chapter.1.c</code> (or
<code>chapter.1.3.c</code> if you&#39;re getting it from the source code repository) to a new
file called <code>chapter.4.1.c</code>.</p>

<p>First, remove all of the <code>#include</code> directives from the file, and replace them
with a single <code>#include</code> to <code>Utils.h</code>:</p>

<!--- 4.3 -->

<script src="https://gist.github.com/EddyLuten/095476c1fe61e9b7a605.js"> </script>

<p>As with each chapter, update <code>WINDOW_TITLE_PREFIX</code> to reflect the current
chapter.</p>

<p>After the <code>FrameCount</code> variable, declare the following block of variables:</p>

<!--- 4.4 -->

<script src="https://gist.github.com/EddyLuten/1055007717fe8949ae1f.js"> </script>

<p>Underneath that, add the following matrices:</p>

<!--- 4.5 -->

<script src="https://gist.github.com/EddyLuten/3ecfb19215078c295652.js"> </script>

<p>Right below that, add the following variable declarations:</p>

<!--- 4.6 -->

<script src="https://gist.github.com/EddyLuten/3d980ad11db92a3bbd7f.js"> </script>

<p>Underneath the declaration of the <code>IdleFunction</code> function, insert the following
new function declarations:</p>

<!--- 4.7 -->

<script src="https://gist.github.com/EddyLuten/771852633450cd7f6e76.js"> </script>

<p>Inside of the <code>Initialize</code> function definition, make the following function call
right above the function call to <code>glClearColor</code>:</p>

<!--- 4.8 -->

<script src="https://gist.github.com/EddyLuten/6963527fb4c2ad1a99eb.js"> </script>

<p>Then, right underneath the call to <code>glClearColor</code>, insert the following lines:</p>

<!--- 4.9 -->

<script src="https://gist.github.com/EddyLuten/5559ad12f033f0b2a33e.js"> </script>

<p>Inside of the <code>InitWindow</code> function definition, right after the function call
to <code>glutTimerFunc</code>, place the following line:</p>

<!--- 4.10 -->

<script src="https://gist.github.com/EddyLuten/90eaa15298c6dfd15462.js"> </script>

<p>Next, inside of the <code>ResizeFunction</code> function definition, underneath the call
to <code>glViewport</code>, insert the following lines:</p>

<!--- 4.11 -->

<script src="https://gist.github.com/EddyLuten/bbba58a6a866bb135229.js"> </script>

<p>In the <code>RenderFunction</code> function definition, right after the call to <code>glClear</code>,
place the following function call:</p>

<!--- 4.12 -->

<script src="https://gist.github.com/EddyLuten/ca507a1e78286ea54762.js"> </script>

<p>We&#39;ll be entering the following function definition piece by piece in logical
steps. First, create the following empty function definition:</p>

<!--- 4.13 -->

<script src="https://gist.github.com/EddyLuten/74fe2527c7f679fba05e.js"> </script>

<p>At the first line of the function, insert the cube&#39;s vertex definitions:</p>

<!--- 4.14 -->

<script src="https://gist.github.com/EddyLuten/617687afdc71a3ee8102.js"> </script>

<p>Right after that, insert the cube&#39;s index definitions:</p>

<!--- 4.15 -->

<script src="https://gist.github.com/EddyLuten/5d782e809d5df7d55401.js"> </script>

<p>After that, place the following shader-program creation code:</p>

<!--- 4.16 -->

<script src="https://gist.github.com/EddyLuten/b06f2085e3f330a1f69f.js"> </script>

<p>Immediately underneath that, place the following shader loading and attaching
code:</p>

<!--- 4.17 -->

<script src="https://gist.github.com/EddyLuten/388c6a4ae16c515ff854.js"> </script>

<p>After that, insert the code to retrieve the shader uniforms:</p>

<!--- 4.18 -->

<script src="https://gist.github.com/EddyLuten/d01acd9ba4e531b665e8.js"> </script>

<p>Right below that, insert the following buffer generation code:</p>

<!--- 4.38 -->

<script src="https://gist.github.com/EddyLuten/4c9cbfead60c762ebfa0.js"> </script>

<p>Insert the following VAO generation and binding code after that:</p>

<!--- 4.19 -->

<script src="https://gist.github.com/EddyLuten/b3471d8ee667beb3132c.js"> </script>

<p>After that, enable the following vertex attribute locations:</p>

<!--- 4.20 -->

<script src="https://gist.github.com/EddyLuten/7a183a810e45a8e7576c.js"> </script>

<p>Insert the following VBO binding, data uploading, and vertex attribute
descriptions after that:</p>

<!--- 4.21 -->

<script src="https://gist.github.com/EddyLuten/83d11077a915c859a5d9.js"> </script>

<p>For the final lines of the function, insert the IBO binding and uploading code:</p>

<!--- 4.22 -->

<script src="https://gist.github.com/EddyLuten/56225d608e9f63c84855.js"> </script>

<p>Immediately after the <code>CreateCube</code> function definition, insert the following
new function definition:</p>

<!--- 4.23 -->

<script src="https://gist.github.com/EddyLuten/e883d46cf87948e4c6e8.js"> </script>

<p>The last function we&#39;ll define draws the cube to the screen. Insert the
following empty function definition immediately after the <code>DestroyCube</code>
function definition:</p>

<!--- 4.24 -->

<script src="https://gist.github.com/EddyLuten/e1f250cac07a404dbd68.js"> </script>

<p>At the first line of the function, insert the following lines used for time-based rotations:</p>

<!-- 4.25 -->

<script src="https://gist.github.com/EddyLuten/d070de499c0cd4b250c1.js"> </script>

<p>After that, insert the following matrix transformations:</p>

<!-- 4.26 -->

<script src="https://gist.github.com/EddyLuten/3dc558e4081bc5db257f.js"> </script>

<p>Immediately after that, insert the following shader related function calls:</p>

<!--- 4.27 -->

<script src="https://gist.github.com/EddyLuten/7c63a0972e30c4f07415.js"> </script>

<p>Finally, insert the last lines of this function used for drawing purposes:</p>

<!-- 4.28 -->

<script src="https://gist.github.com/EddyLuten/89e07362707c7e4a5fad.js"> </script>

<p>Next, create a text file called <code>SimpleShader.vertex.glsl</code>, and insert the
following lines:</p>

<!--- 4.29 -->

<script src="https://gist.github.com/EddyLuten/419748bfb11a3b625fd8.js"> </script>

<p>Lastly, create another text file called <code>SimpleShader.fragment.glsl</code> with the
following containing the following lines:</p>

<!--- 4.30 -->

<script src="https://gist.github.com/EddyLuten/fb062bb7db27595279e5.js"> </script>

<p>After you compile your program, make sure that these GLSL files are in the same
directory as your executable before your run the executable. When you do, the
output should show a spinning cube on your screen, similar to the following
screenshot:</p>

<p><img
  src="/images/Chapter4.1-Output.png"
  alt="Chapter 4 Output"
  title="Chapter 4 Output"
  class="center"
/></p>

<h2>Step-By-Step</h2>

<p>There are many changes from the previous chapters in this chapter, so let&#39;s look
at what just happened. The first thing we did is the same we do for each
chapter, which is to include files and change the window title&#39;s prefix.
However, in this chapter, we replaced all of the <code>#include</code>s with a single
include to <code>Utils.h</code>.</p>

<p>Before we continue describing the code, let&#39;s introduce a few new concepts.</p>

<h3>GLSL Uniforms</h3>

<p>In the previous chapters, we&#39;ve learned that we can declare variables in our
GLSL shaders, but haven&#39;t actually imported any data besides our usual vertex
information. In this chapter, we need a way to transport our matrices to the
vertex shader, and we do so by using so-called <strong>uniforms</strong>.</p>

<p>Uniforms are global variables stored inside of the shader program, changeable
at any time during the lifecycle of the shader program. Once a uniform is set,
it doesn&#39;t change and remains set until another value is set or the program
ends.</p>

<p>Uniforms can be any basic GLSL data type, in our case they are of type <code>mat4</code>,
which represents 4x4 matrices. In a future chapter on shaders, we&#39;ll discuss
more GLSL data types. </p>

<h4>Retrieving Uniform Locations</h4>

<p>Each uniform has a specific location, and after a GLSL shader program links,
these locations become available to OpenGL. The locations are accessible through
their names by calling the OpenGL function <code>glGetUniformLocation</code>:</p>

<!--- 4.31 -->

<script src="https://gist.github.com/EddyLuten/e25a566c36319e3c50f7.js"> </script>

<ul>
<li>The program parameter takes in the shader program&#39;s identifier as generated by
the call to glCreateProgram</li>
<li>The name parameter takes in the name of the uniform variable as defined in the
GLSL source code as a regular character string</li>
</ul>

<p>The function returns the integer uniform location, which we store in our
<code>ModelMatrixUniformLocation</code>, <code>ViewMatrixUniformLocation</code>, and
<code>ProjectionMatrixUniformLocation</code> variables.</p>

<h4>Setting Uniform Data</h4>

<p>Once we have these locations, we can start uploading our matrices to the GPU. To
do so, there are many <code>glUniform</code> functions, one for each basic GLSL data type.
The one we use in our program is <code>glUniformMatrix4fv</code>, which allows us to upload
a 4x4 floating-point matrix:</p>

<!--- 4.32 -->

<script src="https://gist.github.com/EddyLuten/9bf5a2567d98a2697553.js"> </script>

<ul>
<li>The <code>location</code> parameter takes in the location of the uniform as queried by
the <code>glGetUniformLocation</code> function described above</li>
<li>The <code>count</code> parameter takes in the number of matrices passed into this
function: 1 for a single matrix, greater than1 for an array of matrices</li>
<li>The <code>transpose</code> parameter takes in <code>GL_FALSE</code> if the matrix
is in column major order (as in our case), and <code>GL_TRUE</code> if the matrix is in row
major order and requires transposing by OpenGL</li>
<li>The <code>value</code> parameter takes in a pointer to the location in memory of the
first element of the array to upload to the GPU</li>
</ul>

<h3>Matrices in OpenGL</h3>

<p>We represent a matrix as an array of sixteen floating-point numbers. The
identity matrix in C looks like the following piece of code:</p>

<!--- 4.33 -->

<script src="https://gist.github.com/EddyLuten/02c19a85e6cc88791916.js"> </script>

<p>If we lay it out in a bit more readable format (as in <code>Utils.h</code>), we can see the
layout of the matrix:</p>

<!--- 4.34 -->

<script src="https://gist.github.com/EddyLuten/e074bef3945216fbce68.js"> </script>

<p>The matrix&#39;s column vectors occupy contiguous memory, meaning that the x-column
vector occupies indices 0 through 3; the y-column vector occupies indices 4
through 7, and so on.</p>

<p>In our programs, we&#39;ll be using a structure containing one of these arrays named
Matrix, defined in the file <code>Utils.h</code>. All of our helper functions operate on
this structure, not a raw array of floating point numbers.</p>

<p>In this program, we store our matrices in three global variables named
<code>ModelMatrix</code> for the cube&#39;s local transformations, <code>ViewMatrix</code> for the
camera/eye transformation, and <code>ProjectionMatrix</code> for our perspective projection
transformation. These variables have the exact same names as the uniform
variables in our vertex shader, described further on in this chapter.</p>

<h2>Step-By-Step Continued...</h2>

<p>The next set of global variables that we added after our matrices and uniform
locations, are a floating-point number named <code>CubeRotation</code>, and a <code>clock_t</code>
variable named <code>LastTime</code>. We use both of these variables to rotate the cube in
the <code>DrawCube</code> function, which we will describe a bit later on in the chapter.</p>

<p>We added a few more function declarations, and after that edited the
<code>Initialize</code> function.</p>

<h3>New Initialization Code (<code>Initialize</code>)</h3>

<p>While much of the code in the <code>Initialize</code> function remained untouched, we added
some crucial new function calls.</p>

<h4>Depth Testing</h4>

<p>Immediately after the call to <code>glClearColor</code>, we called the function <code>glEnable</code>,
which allows us to enable certain OpenGL capabilities. The capability we wish to
enable is the only parameter we pass to this function. To disable the
capability, simply call <code>glDisable</code> with the same flag, which we do not use in
our program.</p>

<p>The flag we pass into <code>glEnable</code> is <code>GL_DEPTH_TEST</code>, which allows OpenGL to
compare the depth values of fragments after rasterization. Besides the
<code>GL_DEPTH_TEST</code> capability enabled, OpenGL also needs to know exactly how to
compare the fragments. We do this by a call to <code>glDepthFunc</code>, which defines
when to store a fragment in the depth buffer, or when to discard by passing in
one of the following enumerations:</p>

<ul>
<li><code>GL_NEVER</code>: a fragment never passes the depth test.</li>
<li><code>GL_LESS</code>: a fragment passes when its depth value is less (closer to the
camera) than the fragment currently stored in the depth buffer. We use this
enumeration in our program.</li>
<li><code>GL_EQUAL</code>: a fragment passes the depth test when its depth value is equal to
the one currently stored in the depth buffer.</li>
<li><code>GL_LEQUAL</code>: a fragment passes the depth test when its depth value is less or
equal to the one currently stored in the depth buffer.</li>
<li><code>GL_GREATER</code>: the opposite of <code>GL_LESS</code>.</li>
<li><code>GL_NOTEQUAL</code>: the opposite of <code>GL_EQUAL</code>.</li>
<li><code>GL_GEQUAL</code>: a fragment passes the depth test when its depth value is greater
or equal to the one currently stored in the depth buffer.</li>
<li><code>GL_ALWAYS</code>: the opposite of <code>GL_NEVER</code>.</li>
</ul>

<h4>OpenGL Error Checking</h4>

<p>After the call to <code>glDepthFunc</code>, we call another new function is, namely our
custom <code>ExitOnGLError</code> function. This function, as its name suggests, checks for
an OpenGL error, and if one is present, immediately exits the program. A single
parameter, <code>error_message</code>, is required that contains the error message to
display to the user if the program exits erroneously.</p>

<h4>Polygon Culling</h4>

<p>This next concept is very important from this chapter onwards. Whereas in
previous chapters we didn&#39;t care which way we constructed our vertices, with
polygon culling, a method that reduces the amount of polygons to render, it
becomes critical. For instance, if we didn&#39;t specify polygon culling in this
chapter, rendering also occurs on the insides of the cube, even though they are
not visible.</p>

<p>The first function call is once again <code>glEnable</code>, this time passing in the
<code>GL_CULL_FACE</code> flag to enable the polygon capability on the graphics hardware.</p>

<p>The next function is <code>glCullFace</code>, which defines which face of the polygon to
cull. We can cull either the front-face of the polygon by supplying the function
with the <code>GL_FRONT</code> enumeration, the back-face of the polygon with <code>GL_BACK</code>, or
both faces with <code>GL_FRONT_AND_BACK</code>. Yet, how do you determine which face is the
front-face and which face is the back-face of a polygon?</p>

<p>The answer is by defining in which direction a polygon&#39;s vertices wind, either
clockwise or counterclockwise. Vertex winding defines the path OpenGL takes to
complete the polygon, starting at the first vertex, then the second vertex, and
so on until the polygon is closed. We specify this direction with a call to
<code>glFrontFace</code>, which defines the direction in which the vertices of a polygon
wind. In our case, this is counterclockwise, specified by the <code>GL_CCW</code>
enumeration, its opposite is <code>GL_CW</code> for clockwise winding vertices.</p>

<h4>Matrix Initialization</h4>

<p>After the OpenGL options are set, we initialize the matrices by setting them to
the identity matrix. The view matrix, which describes the eye transformations,
is translated two units into the negative z direction (backwards) so that the
camera won&#39;t intersect the cube.</p>

<h3>Creating the Cube (<code>CreateCube</code>)</h3>

<p>We didn&#39;t encounter any new concepts in the <code>CreateCube</code> function; we still
generate a bunch of buffers for vertex and index data and push them to the GPU.
The only differences from the previous chapter are the retrieval of the shader
uniforms described earlier and a new custom function named <code>LoadShader</code>.</p>

<h4>Loading Shaders from Files</h4>

<p>Previously, we hard-coded our GLSL shaders into our code as one giant constant
string, from now on, we&#39;ll use the <code>LoadShader</code> function to load them from text
files instead, its prototype looks like this:</p>

<!--- 4.35 -->

<script src="https://gist.github.com/EddyLuten/0538fa1225b581c89748.js"> </script>

<ul>
<li>The <code>filename</code> parameter takes in the filename of the GLSL shader to read</li>
<li>The <code>shader_type</code> parameter takes in the <code>GLenum</code> that we used to pass into
<code>glCreateShader</code>, in this program we use <code>GL_FRAGMENT_SHADER</code> and
<code>GL_VERTEX_SHADER</code></li>
</ul>

<p>The function reads the contents from the file, generates a shader identifier,
passes the contents of the file into <code>glShaderSource</code>, and compiles the shader.
The function returns the identifier generated by the call to <code>glCreateShader</code>.</p>

<h3>Drawing the Cube (<code>DrawCube</code>)</h3>

<p>The first section of the <code>DrawCube</code> function deals with generating a rotation
angle based on the amount of time has passed. The rotation we use in this
sample is 45 degrees per second, which we achieve by checking the amount of
clock ticks passed since the last time the <code>DrawCube</code> function executed. The
previous clock ticks are stored in the global variable <code>LastTime</code>, whereas the
current ticks are stored in the local variable named <code>Now</code>.</p>

<p>The total rotation in degrees is stored in the global variable named
<code>CubeRotation</code>. However, in order to use this rotation in OpenGL, we need to
convert the degrees to radians, done through a function call to our custom
function <code>DegreesToRadians</code>. This value is then stored in the local <code>CubeAngle</code>
variable and used to apply rotational transformations to the model matrix by
calling <code>RotateAboutY</code>, followed by a call to <code>RotateAboutX</code>.</p>

<p>Unlike in the previous chapters, we enable and disable the shader program as
well as the VAO each draw call instead of just once to demonstrate how a scene
with multiple objects is usually drawn. We&#39;ll introduce multiple objects to our
scene in a future chapter, although there is nothing special about it, and by
now, you should be able to work out how to do this from the information
presented throughout the chapters.</p>

<h3>Vertex Shader Changes</h3>

<p>Besides changes to the C code, there were also some minor changes to the vertex
shader from the previous chapter to the current one.</p>

<p>The first major change is the addition of the uniform variables described
earlier in the chapter. In the GLSL source code, they look like this:</p>

<!--- 4.36 -->

<script src="https://gist.github.com/EddyLuten/e07ab8b36747caad538d.js"> </script>

<p>As mentioned earlier, the matrices in the shader have the exact same names as
the ones in the source code. This is not a requirement, but simply to show the
relationship between the two.</p>

<p>The final notable change to the vertex shader is the calculation of the final
vertex position:</p>

<!--- 4.37 -->

<script src="https://gist.github.com/EddyLuten/2832fcabb2e37a37bc15.js"> </script>

<p>As you can see, the transformation for the vertex happens by multiplying the
matrices together to form one transformation matrix (the multiplication between
the parentheses), and multiplying <code>in_Position</code> with it to obtain the
coordinates passed on to OpenGL.</p>

<h1>Conclusion</h1>

<p>In this chapter, we rendered our first three-dimensional geometry onto the
screen and learned about the basic transformations used in computer graphics.</p>

<p>If you&#39;re fuzzy on matrix mathematics or linear algebra in general, here are a
few resources to get you up to speed since the topic is too broad to handle on
this site:</p>

<ul>
<li><a href="http://www.khanacademy.com">The Khan Academy</a>, tons of great video tutorials
on mathematics.</li>
<li><a href="http://www.j3d.org/matrix_faq/matrfaq_latest.html">The matrix and quaternions FAQ</a></li>
<li>Any search result page on Google for &quot;linear algebra,&quot; &quot;matrix math,&quot; or
&quot;3D math&quot; will do.</li>
</ul>

<p>Until the next chapter is ready, try the following exercises:</p>

<ul>
<li>Create a keyboard movable camera by transforming the <code>ViewMatrix</code> matrix
through keyboard input (see chapter 3 for FreeGLUT keyboard input), copied to
the GPU each time <code>DrawCube</code> executes.</li>
<li>Work out how to draw multiple cubes onto the screen.</li>
</ul>

<p>You can find the source code for the samples in this chapter
<a href="https://github.com/openglbook/openglbook-samples/tree/master/chapter-4">here.</a></p>



          <div class="footer">

            <div class="contact">
              <p>
                <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
                  <img
                    alt="Creative Commons License"
                    style="border-width:0"
                    src="http://i.creativecommons.org/l/by-sa/4.0/88x31.png"
                  />
                </a>
              </p>
            </div>

            <div class="contact">
              <p>
                If you were charged for a copy of this text,
                <em>demand a refund</em>. This work is available free of charge
                at <a href="http://openglbook.com/">openglbook.com</a>
              </p>
            </div>

            <div class="contact">
              <p>
                <a href="https://github.com/openglbook">Fork us on GitHub</a>
              </p>
            </div>

          </div>
        </div>

        <a href="https://github.com/openglbook">
          <img
            style="position: absolute; top: 0; right: 0; border: 0;"
            src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67"
            alt="Fork me on GitHub"
            data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"
          />
        </a>

        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-301718-10', 'openglbook.com');
          ga('send', 'pageview');
        </script>
    </body>
</html>
